#!/usr/bin/env python
import json
import os
import sys
from abc import ABC, abstractmethod

import requests

os_name = "MacOS" if os.uname().sysname == "Darwin" else "Linux"

system_prompt = f"""
You are a Unix shell assistant. Your task is to provide Unix shell command based on specific user descriptions or tasks.
Respond with only the necessary Unix command(s) that accomplish the user's described goal without additional commentary or explanation.

# Steps
- Read the task or goal described by the user carefully.
- Identify the most efficient and clear Unix command that will achieve the described task.
- The command should be available in the operating system: {os_name}.
- Provide only the command necessary to accomplish the task. Do not include explanations, descriptions, or additional information.

# Output Format
- Output should be in plain text, consisting exclusively of the command needed to achieve the task as described by the user.
- Do not use markdown or any extra characters, just the shell command itself.
- If multiple commands are needed, join them with AND signs (&&).
"""


class Adapter(ABC):
    @property
    @abstractmethod
    def token(self) -> str:
        pass

    @property
    @abstractmethod
    def base_url(self) -> str:
        pass

    @property
    @abstractmethod
    def model(self) -> str:
        pass

    @property
    def headers(self) -> dict[str, str]:
        return {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json",
        }

    def howto(self, input: str) -> str:
        payload = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": input},
            ],
        }
        rsp = requests.post(
            f"{self.base_url}/chat/completions",
            headers=self.headers,
            json=payload,
        ).json()
        try:
            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=self.headers,
                json=payload,
            )
            response.raise_for_status()
            rsp = response.json()
            return rsp["choices"][0]["message"]["content"]
        except requests.exceptions.RequestException as e:
            return f"An error occurred: {e}"


class Copilot(Adapter):
    @property
    def _oauth_token(self) -> str:
        config_dir = os.environ.get(
            "XDG_CONFIG_HOME", os.path.join(os.environ["HOME"], ".config")
        )

        with open(os.path.join(config_dir, "github-copilot/apps.json")) as f:
            obj = json.load(f)
            for key, value in obj.items():
                if key.startswith("github.com:"):
                    return value["oauth_token"]
            raise RuntimeError("Could not find token")

    @property
    def token(self) -> str:
        return requests.get(
            "https://api.github.com/copilot_internal/v2/token",
            headers={
                "Authorization": f"Bearer {self._oauth_token}",
                "Accept": "application/json",
            },
        ).json()["token"]

    @property
    def base_url(self) -> str:
        return "https://api.githubcopilot.com"

    @property
    def model(self) -> str:
        return "gpt-4o"

    @property
    def headers(self) -> dict[str, str]:
        headers = super().headers
        headers["Copilot-Integration-Id"] = "vscode-chat"
        headers["editor-version"] = "Neovim/0.10.0"
        return headers


class Deepseek(Adapter):
    @property
    def token(self) -> str:
        return os.environ["DEEPSEEK_API_KEY"]

    @property
    def base_url(self) -> str:
        return "https://api.deepseek.com"

    @property
    def model(self) -> str:
        return "deepseek-chat"


def main():
    adapters: dict[str, Adapter] = {
        "copilot": Copilot(),
        "deepseek": Deepseek(),
    }

    adapter_name = os.environ.get("HOWTO_ADAPTER", "copilot")
    adapter = adapters[adapter_name]

    input = sys.stdin.read()
    ans = adapter.howto(input)
    print(ans)


if __name__ == "__main__":
    main()
